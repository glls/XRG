/* 
 * XRG (X Resource Graph):  A system resource grapher for Mac OS X.
 * Copyright (C) 2002-2022 Gaucho Software, LLC.
 * You can view the complete license in the LICENSE file in the root
 * of the source tree.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

//
//  XRGTemperatureMiner.m
//

#import "XRGTemperatureMiner.h"
#import "XRGAppleSiliconSensorMiner.h"
#import "XRGStatsManager.h"
#import "definitions.h"

#import <mach/mach_host.h>
#import <mach/mach_port.h>
#import <mach/vm_map.h>

#undef DEBUG

@interface XRGTemperatureMiner ()

@property NSInteger numSamples;                    // for the XRGDataSets, number of samples to record.
@property NSInteger temperatureCounter;            // count and only grab the temperature every 5 seconds.

@property NSMutableDictionary<NSString *,XRGSensorData *> *sensorData;
@property NSMutableArray<NSString *> *locationKeysInOrder;        // locations in certain order, returned by locationKeysInOrder, generated by regenerateLocationKeyOrder.

@property NSArray *fanCache;
@property NSDate *fanCacheCreated;
@property NSMutableDictionary *fanLocations;

@end

@implementation XRGTemperatureMiner

+ (instancetype)shared {
    static XRGTemperatureMiner *sharedMiner = nil;

    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedMiner = [[XRGTemperatureMiner alloc] init];
    });

    return sharedMiner;
}

- (instancetype)init {
	self = [super init];
	
	if (self) {
		host = mach_host_self();
		
		unsigned int count = HOST_BASIC_INFO_COUNT;
		host_basic_info_data_t info;
		host_info(host, HOST_BASIC_INFO, (host_info_t)&info, &count);
		
		// Set the number of CPUs
		numCPUs = [self numberOfCPUs];
		
		self.fanLocations = [NSMutableDictionary dictionary];
		self.locationKeysInOrder = [NSMutableArray array];
		self.sensorData = [NSMutableDictionary dictionary];
		self.smcSensors = [[SMCSensors alloc] init];
	}

    return self;
}

- (void)reset {
    for (XRGSensorData *sensor in [self.sensorData allValues]) {
        [sensor.dataSet reset];
    }
}

- (NSInteger)numberOfCPUs {
    processor_cpu_load_info_t		newCPUInfo;
    kern_return_t					kr;
    unsigned int					processor_count;
    mach_msg_type_number_t			load_count;

    kr = host_processor_info(host, 
                             PROCESSOR_CPU_LOAD_INFO, 
                             &processor_count, 
                             (processor_info_array_t *)&newCPUInfo, 
                             &load_count);
    if (kr != KERN_SUCCESS) {
        return 0;
    }
    else {
        vm_deallocate(mach_task_self(), (vm_address_t)newCPUInfo, (vm_size_t)(load_count * sizeof(*newCPUInfo)));
        return (int)processor_count;
    }
}

- (void)updateCurrentTemperatures:(BOOL)includeUnknown {
    // Only refresh the temperature every 5 seconds.
    self.temperatureCounter = (self.temperatureCounter + 1) % 5;
    if (self.temperatureCounter != 1) {
        return;
    }
    
	// Set each temperature sensor enable bit to NO.
    for (XRGSensorData *sensor in self.sensorData.allValues) {
        sensor.isEnabled = NO;
	}
    	
	// Gather SMC Data
	@try {
        [self trySMCTemperature:includeUnknown];
	} @catch (NSException *e) {}
    
    // Gather Apple Silicon Data
    [self tryAppleSiliconTemperature];
    
	// Before returning, go through the values and find the ones that aren't enabled.
    for (XRGSensorData *sensor in self.sensorData.allValues) {
        if (!sensor.isEnabled) {
            [sensor.dataSet setNextValue:0];
            sensor.currentValue = 0;
        }
    }
}

- (void)trySMCTemperature:(BOOL)includeUnknown {
	NSDictionary *temperatureValues = [self.smcSensors temperatureValuesIncludingUnknown:includeUnknown];

    for (NSString *key in temperatureValues) {
		id aValue = temperatureValues[key];
		if (![aValue isKindOfClass:[NSNumber class]]) continue;		// Fix TE..
        
		float temperature = [aValue floatValue];
		// Throw out temperatures that are too low or too high to be reasonable.
		if (temperature < 15 || temperature > 150) {
			continue;
        }

		[self setCurrentValue:temperature
					 andUnits:[NSString stringWithFormat:@"%CC", (unsigned short)0x00B0] 
				  forLocation:key];
	}
    
    NSDictionary *fanValues = [self.smcSensors fanValues];
    for (NSString *fanKey in fanValues) {
        id fanDict = fanValues[fanKey];

        // Find the actual fan speed key.
        NSArray *fanDictKeys = [fanDict allKeys];
        NSUInteger speedKeyIndex = [fanDictKeys indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop){
            if ([obj hasSuffix:@"Ac"]) {
                *stop = YES;
                return YES;
            }

            return NO;
        }];
        if (speedKeyIndex != NSNotFound) {
            id fanSpeedKey = fanDictKeys[speedKeyIndex];
            if ([fanDict[fanSpeedKey] isKindOfClass:[NSData class]]) {
                float *speed = (float *)[fanDict[fanSpeedKey] bytes];
                [self setCurrentValue:*speed
                             andUnits:@" rpm"
                          forLocation:fanSpeedKey];
            }
            else {
                [self setCurrentValue:[fanDict[fanSpeedKey] floatValue]
                             andUnits:@" rpm"
                          forLocation:fanSpeedKey];
            }
        }
    }
}

- (void)tryAppleSiliconTemperature {
    NSDictionary *appleSiliconSensorData = [XRGAppleSiliconSensorMiner sensorData];
    
    for (NSString *key in appleSiliconSensorData) {
        id aValue = appleSiliconSensorData[key];
        if (![aValue isKindOfClass:[NSNumber class]]) continue;
        
        float temperature = [aValue floatValue];
        // Throw out temperatures that are too low or too high to be reasonable.
        if (temperature < 15 || temperature > 150) {
            continue;
        }

        [self setCurrentValue:temperature
                     andUnits:[NSString stringWithFormat:@"%CC", (unsigned short)0x00B0]
                  forLocation:key];
    }
}

- (NSArray *)locationKeysIncludingUnknown:(BOOL)includeUnknown {
    if (includeUnknown) {
        return self.locationKeysInOrder;
    }
    else {
        NSMutableArray *filteredArray = [NSMutableArray array];

        for (NSString *key in self.locationKeysInOrder) {
            if ([self.smcSensors isKnownKey:key]) {
                [filteredArray addObject:key];
            }
        }

        return filteredArray;
    }
}

- (NSArray<NSString *> *)allSensorKeys {
    return [self.sensorData allKeys];
}

- (XRGSensorData *)sensorForLocation:(NSString *)location {
    return self.sensorData[location];
}

- (BOOL)isFanSensor:(XRGSensorData *)sensor {
    return [self fanForSensor:sensor] != nil;
}

- (void)regenerateLocationKeyOrder {
    NSArray        *locations        = [self.sensorData allKeys];
    NSInteger      numLocations      = [locations count];
    if (numLocations == 0) return;
    
    BOOL alreadyUsed[numLocations];

	[self.locationKeysInOrder removeAllObjects];

    for (int i = 0; i < numLocations; i++) {
        if (locations[i] == nil) {
            alreadyUsed[i] = YES;
        } else {
            alreadyUsed[i] = NO;
        }
    }
    
	NSMutableArray *types = [NSMutableArray arrayWithObjects:
		[NSString stringWithFormat:@"%CC", (unsigned short)0x00B0], 
		@" rpm", 
		@"%", 
		nil];

	int typeIndex;
	for (typeIndex = 0; typeIndex < [types count]; typeIndex++) {
		NSMutableArray *tmpCPUCore = [NSMutableArray array];
		NSMutableArray *tmpCPUA    = [NSMutableArray array];
		NSMutableArray *tmpCPUB    = [NSMutableArray array];
		NSMutableArray *tmpCPU     = [NSMutableArray array];
		NSMutableArray *tmpU3      = [NSMutableArray array];
		NSMutableArray *tmpGPU     = [NSMutableArray array];
		NSMutableArray *tmpBattery = [NSMutableArray array];
		NSMutableArray *tmpDrive   = [NSMutableArray array];
		NSMutableArray *tmpOthers  = [NSMutableArray array];
        NSMutableArray *tmpFans    = [NSMutableArray array];
        NSMutableArray *tmpUnknown = [NSMutableArray array];
		
		for (int i = 0; i < numLocations; i++) {
			if (alreadyUsed[i]) continue;
			
			NSString *location = locations[i];
			if (![self.sensorData[location].units isEqualToString:types[typeIndex]]) {
				continue;
			}

            NSString *humanReadableLocation = self.sensorData[location].humanReadableName;
            if (!humanReadableLocation || [humanReadableLocation isEqualTo:self.sensorData[location].key]) {
                [tmpUnknown addObject:location];
                alreadyUsed[i] = YES;
                continue;
            }

			// Matches CPU and CORE
			NSRange r = [humanReadableLocation rangeOfString:@"CPU"];
			if (r.location != NSNotFound) {
				r = [humanReadableLocation rangeOfString:@"Core"];
				if (r.location != NSNotFound) {
					[tmpCPUCore addObject:location];
					alreadyUsed[i] = YES;
					continue;
				}
			}
			
			// Matches CPU A
			r = [humanReadableLocation rangeOfString:@"CPU A"];
			if (r.location != NSNotFound) {
				[tmpCPUA addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
		
			// Matches CPU B
			r = [humanReadableLocation rangeOfString:@"CPU B"];
			if (r.location != NSNotFound) {
				[tmpCPUB addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
		
			// Matches CPU
			r = [humanReadableLocation rangeOfString:@"CPU"];
			if (r.location != NSNotFound) {
				[tmpCPU addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
					
			// Matches U3 (for the memory controller in a G5)
			r = [humanReadableLocation rangeOfString:@"U3"];
			if (r.location != NSNotFound) {
				[tmpU3 addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
			
			// Matches Memory (for Intel SMC)
			r = [humanReadableLocation rangeOfString:@"Memory"];
			if (r.location != NSNotFound) {
				[tmpU3 addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}			
		
			// Matches GPU
			r = [humanReadableLocation rangeOfString:@"GPU"];
			if (r.location != NSNotFound) {
				[tmpGPU addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
		
			// Add any that match Battery
			r = [humanReadableLocation rangeOfString:@"BATTERY"];
			if (r.location != NSNotFound) {
				[tmpBattery addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
		
			// Add any that match Drive
			r = [humanReadableLocation rangeOfString:@"DRIVE"];
			if (r.location != NSNotFound) {
				[tmpDrive addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
			
			r = [humanReadableLocation rangeOfString:@"HDD"];
			if (r.location != NSNotFound) {
				[tmpDrive addObject:location];
				alreadyUsed[i] = YES;
				continue;
			}
		}
		
		// Loop through and add any left overs
		for (int i = 0; i < numLocations; i++) {
			if ((!alreadyUsed[i]) & [self.sensorData[locations[i]].units isEqualToString:types[typeIndex]]) {
				[tmpOthers addObject:locations[i]];
				alreadyUsed[i] = YES;
			}
		}
		
        NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:@"self"
                                                                         ascending:YES
                                                                        comparator:^(id obj1, id obj2) {
                                                                            return [obj1 compare:obj2];
                                                                        }];
        
		[self.locationKeysInOrder addObjectsFromArray:[tmpCPUCore sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpCPUA sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpCPUB sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpCPU sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpGPU sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpU3 sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpBattery sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpDrive sortedArrayUsingDescriptors:@[descriptor]]];
		[self.locationKeysInOrder addObjectsFromArray:[tmpOthers sortedArrayUsingDescriptors:@[descriptor]]];
        [self.locationKeysInOrder addObjectsFromArray:[tmpFans sortedArrayUsingDescriptors:@[descriptor]]];
        [self.locationKeysInOrder addObjectsFromArray:[tmpUnknown sortedArrayUsingDescriptors:@[descriptor]]];
	}
}

- (void)setCurrentValue:(float)value andUnits:(NSString *)units forLocation:(NSString *)location {
	BOOL needRegen = NO;
	
	// Need to find the right dictionary for this location
	XRGSensorData *sensor = self.sensorData[location];
	
	// If we didn't find it, we need to create a new one and insert it into our collection.
	if (sensor == nil) {
		sensor = [[XRGSensorData alloc] initWithSensorKey:location];
        self.sensorData[location] = sensor;
		needRegen = YES;
	}
	
	// Set the units
	sensor.units = units;
		
	// Set the current value in the sensor data dictionary
	sensor.currentValue = value;
	
	// Set that this sensor is enabled.
    sensor.isEnabled = YES;
	
	// Set the next value in the data set.
	if (sensor.dataSet == nil) {
		// we have to create an XRGDataSet for this location.
		XRGDataSet *newSet = [[XRGDataSet alloc] init];
		[newSet resize:(size_t)self.numSamples];
		[newSet setAllValues:value];
		sensor.dataSet = newSet;
	}
	[sensor.dataSet setNextValue:value];
	
	// If this location doesn't have a label, generate one.
	if (sensor.humanReadableName == nil) {
		if ([location isEqualToString:@"CPU A AD7417 AMB"]) {
			sensor.humanReadableName = @"CPU A Ambient";
		}
		else if ([location isEqualToString:@"CPU B AD7417 AMB"]) {
			sensor.humanReadableName = @"CPU B Ambient";
		}
		else {
			sensor.humanReadableName = [self.smcSensors humanReadableNameForKey:location];
		}
	}
				
	// Regenerate our location keys if needed
	if (needRegen) [self regenerateLocationKeyOrder];

    // Record in XRGStatsManager
    [[XRGStatsManager shared] observeStat:value forKey:location inModule:XRGStatsModuleNameTemperature];

	#ifdef DEBUG
		NSLog(@"Set current value: %f (%@) for location: (%@)", value, units, location);
	#endif
	
	return;
}

- (void)setDataSize:(NSInteger)newNumSamples {
    NSArray *a = [self.sensorData allKeys];

    for (int i = 0; i < [a count]; i++) {
		[self.sensorData[a[i]].dataSet resize:(size_t)newNumSamples];
    }
    
    self.numSamples = newNumSamples;
}

- (NSArray<XRGFan *> *)fanValues {
    if (self.fanCache && ([self.fanCacheCreated timeIntervalSinceNow] > -1)) {
        return self.fanCache;
    }
    
    NSMutableArray *retFans = [NSMutableArray array];
    
    NSDictionary *fansD = [self.smcSensors fanValues];
    for (NSString *key in [fansD allKeys]) {
        XRGFan *f = [[XRGFan alloc] init];
        f.name = key;
        
        id fanD = fansD[key];
        for (NSString *fanDKey in [fanD allKeys]) {
            id fanValue = fanD[fanDKey];
            
            if ([fanValue isKindOfClass:[NSNumber class]]) {
                if ([fanDKey hasSuffix:@"Ac"]) {
                    f.key = fanDKey;
                    f.actualSpeed = [fanValue integerValue];
                }
                else if ([fanDKey hasSuffix:@"Tg"]) {
                    f.targetSpeed = [fanValue integerValue];
                }
                else if ([fanDKey hasSuffix:@"Mn"]) {
                    f.minimumSpeed = [fanValue integerValue];
                }
                else if ([fanDKey hasSuffix:@"Mx"]) {
                    f.maximumSpeed = [fanValue integerValue];
                }
            }
        }
        
        [retFans addObject:f];
    }

    self.fanCache = retFans;
    self.fanCacheCreated = [NSDate date];
    
    return retFans;
}

- (XRGFan *)fanForSensor:(XRGSensorData *)sensor {
    NSArray *fans = [self fanValues];

    for (XRGFan *fan in fans) {
        if ([fan.key isEqualToString:sensor.key]) {
            return fan;
        }
    }

    return nil;
}

- (NSInteger)maxSpeedForFan:(XRGSensorData *)sensor {
    return [self fanForSensor:sensor].maximumSpeed;
}

@end

@implementation XRGFan
@end

@implementation XRGSensorData

- (instancetype)initWithSensorKey:(NSString *)key {
    if (self = [super init]) {
        self.key = key;
    }
    return self;
}

- (NSString *)label {
    return self.humanReadableName ? self.humanReadableName : self.key;
}

@end
